from Crypto.Signature.pss import MGF1
from Crypto.Hash import SHA256
from Crypto.Util.strxor import strxor
from Crypto.Util.Padding import unpad
BYTE_LEN_RANDOMNESS = 128



def recover_factors_from_roots(r1, r2, n):
    # r1 ≠ ±r2 mod n
    g = gcd(r1 - r2, n)
    if 1 < g < n:
        return g, n // g
    return None, None
def sqrtmod(c, p, q):
    # Racines modulo p et q (p, q ≡ 3 mod 4)
    r_p = power_mod(c, (p + 1) // 4, p)
    r_q = power_mod(c, (q + 1) // 4, q)
    
    # Utilisation du CRT pour combiner les racines
    roots = []
    for s_p in [r_p, -r_p % p]:
        for s_q in [r_q, -r_q % q]:
            root = crt([s_p, s_q], [p, q])
            roots.append(root)
    return roots

def mgf(seed, length):
    return MGF1(seed, length, SHA256)

def decrypt(c, p, q):
    n = p * q
    BYTE_LEN_MESSAGE_PART = int(log(n,2))//8 - BYTE_LEN_RANDOMNESS

    roots = sqrtmod(c, p, q)
    for x in roots:
        m_bytes = x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')
        
        # On vérifie que la taille est correcte
        if len(m_bytes) < BYTE_LEN_RANDOMNESS:
            continue
        m_padded_xor = m_bytes[:BYTE_LEN_MESSAGE_PART]
        r = m_bytes[BYTE_LEN_MESSAGE_PART:BYTE_LEN_MESSAGE_PART+BYTE_LEN_RANDOMNESS]
        if len(r) != BYTE_LEN_RANDOMNESS:
            continue

        h = mgf(r, BYTE_LEN_MESSAGE_PART)
        m_padded = strxor(m_padded_xor, h)

        try:
            m = unpad(m_padded, BYTE_LEN_MESSAGE_PART, style='iso7816')
            return m
        except ValueError:
            continue
    raise Exception("Decryption failed: valid root not found")


# Données fournies dans le fichier
n = 25069901080586055706527142652296635221778784942333130306345885961464209951498584504134637247406733712719699393849867054799000226444225391463540293850447779121560927869183801917962368169552786190132991536118104114676058180682902138939938521418136076751407871281455446572040552944824830192732674927246871159031262762017583816799408563185623983099767222220894425743708449809627834541033610765309625242947849669228443536544457864634125698223074259709360234721279233554184606111007189654942623463139397089580191444493668788843536600710474215480130471995675286959637576934091685388438301607923626777322872292406391081578757
c = 11664108339027714421833926122247065602495109325744779455837852011155049112220385112125125889172861710376725975324695941063125430126207833047725499876438658760769913138488158581566047092711604684572539291502444473794535545952141854613304133659851881843185267501221861321279256864842359667544877113167288739705055926788302954079073969729206866514586992751654478762102037569126476184172718562942497158273465188636145349575229988337216001622353422815431066009610312685844592419332504583843696123324113010016192595041897393236822503263338118535206582418073954168434484552102522066423380867688475136773823431989313260270173
roots =  [23403442470187189082751345285261002474842271483208916309293316062452147341490297089116548249708840353921966644865787091570075191690927216829097513099154558948694781547103383181518605909286112688756117609392849468540323359174774919396490477507227165290627233685836940771251308818462326115060303690133043572189191329206535378617765611194158884974715178403474916414050676326334133146457972955901116766170466633209794430263207262141281808115310439875496928367354298451644627591940849665583563793062047963840245430908469191485776009500482682070624116763615260156340599652780607712998327968685024859028564328257551667468665, 125000459835582951103496528350492949467458606994713841025036841299257974768125166342825471167419035050292420280289277011218057055052189490290695607450896539613463006761407232133188063196876823324956089940030916747919829268437611406149294449539409122953037204500946440517383434377929390833847615532814840002855031625472761074678892899097141845647691524377813459284991210943506194867358650320193796632900485262094706460051702985965343947598504287817563024704231613312364921063099146373233110779444827247026865289997547027364227431168687754232397742478177978743014527374009821716219051046600992795937165820631006896741, 24944900620750472755423646123946142272311326335338416465320849120164951976730459337791811776239314677669406973569577777787782169389173201973249598242996882581947464862422394685829180106355909366808035446178073197928138351414464527533789226968596667628454834076954500131523169510446900801898827311714056319028407730392111055724729670286526841254119530696516612284423458598684328346166252114989431446314949183966348830084406161648160354275475755421542671696575001940872241189944090508569390352359952262333164579203671241816172373279305527725898074253197108980894562406717675566722082556877025784526935126585760074682016, 1666458610398866623775797367035632746936513459124213997052569899012062610008287415018088997697893358797732748984079963228925034753298174634442780751293220172866146322080418736443762260266673501376873926725254646135734821508127219543448043910908911460780637595618505800789244126362504077672371237113827586842071432811048438181642951991465098125052043817419509329657773483293701394575637809408508476777383036018649106281250602492843890107763819833863306353924935102539978519066339989359059670077349125739946013585199597357760591209991533409506355232060026803296977281311077675439973639238601918294307964148839414110092]
challenge = 16411745404002444925272517200892623591120111371779358747379227681629993625924223746776857108137408657238413239050654775123195406852098195041505082293617337007291002538893657824065991336033009778342538586963902638557388912818242338658880913714931107413145284664834427086842804187134749925032966327222280318559734056414733696271665097240396640536456717337417553947657152667774031347752973745479334651202073856006771289327506325207193195886351839640604145493182255329649603622735390988930461699348466928351723867311422952670079653343861198625799984638413237749761010171104658479383755977514597394655101047564963366285498

# Étape 1 : factorisation
for i in range(len(roots)):
    for j in range(i + 1, len(roots)):
        p, q = recover_factors_from_roots(roots[i], roots[j], n)
        if p and q:
            print(f"Facteurs récupérés : p = {p}, q = {q}")
            break

# Étape 2 : déchiffrer le challenge
m_challenge = decrypt(challenge, p, q)
print("Message challenge déchiffré :", m_challenge)
